import sys
import csv
import math
import random
import cPickle as pickle
import matplotlib.pylab as plt

"""executeDT.py
	Classifies the given data over the provided
	decision trees 
	@Author : Mayur Sanghavi
	@Author : Lee Avital
	@Version : 1.0 1st May, 2014
"""

#Classifies the data
def test():
	file1 = open(sys.argv[1])
	str = csv.reader(file1)
	data = []
	#Read the test data
	for s in str:
		data.append([float(s[0]), float(s[1]), float(s[2])])
	tree = pickle.load(open(sys.argv[2],'rb'))
	correct = 0
	incorrect = 0
	profit = [[0.2, -0.07, -0.07, -0.07], [-0.07, 0.15, -0.07, -0.07], [-0.07, -0.07, 0.05, -0.07], [-0.03, -0.03, -0.03, -0.03]]
	conf = []
	for i in range(4):
		conf.append([0,0,0,0])
	
	for d in data:
	#For all rows of data
		prob = [0.0,0.0,0.0,0.0]
		for t in tree:
		#Run over all trees and add probabilities 
			if d[t[0]] <= t[1]:
				if d[t[2]] <= t[3]:
					prob[t[6]-1] += t[7]
				else :
					prob[t[8]-1] += t[9]
			else:
				if d[t[4]] <= t[5]:
					prob[t[10]-1] += t[11]
				else:
					prob[t[12]-1] += t[13]
		for i in range(len(prob)):
			prob[i] = prob[i] / len(tree)
		#Select max probability as class
		res = prob.index(max(prob)) +1
		#Confidence matrix
		conf[int(res)-1][int(d[2])-1] += 1
		#Verify if correct or wrong
		if(res == d[2]):
			correct += 1
		else:
			incorrect += 1
	total = 0.0
	#Calculate profit
	for i in range(4):
		for j in range(4):
			total = total + conf[i][j]*profit[i][j]
	print 'Number of Errors: ',incorrect
	print 'Recognition Rate: ', (correct*100.0)/(correct + incorrect), '%'
	print 'Profit Obtained: $', total
	s = ['bolt','nut','ring','scrap']
	print 'Confusion Matrix: '
	print '\t',s[0],'\t',s[1],'\t',s[2],'\t',s[3]
	for i in range(4):
		print s[i],'\t',
		for j in range(4):
			print conf[i][j],'\t',
		print ''
	
	plt.xlabel("Rotational Symmetry")
	plt.ylabel("Eccentricity")
	plt.title("Test Data\nbolt(red) nut(blue) ring(green) scrap(black)")
	for d in data:
		#bolt
		if(d[2] == 1):
			plt.plot(d[0],d[1],'rs')
		#nut
		elif(d[2] == 2):
			plt.plot(d[0],d[1],'bo')
		#ring
		elif(d[2] == 3):
			plt.plot(d[0],d[1],'go')
		#scrap
		elif(d[2] == 4):
			plt.plot(d[0],d[1],'k^')
	
	
#Plots the class region generated by the
#given trees for input over{(0..1), (0..1)}
def region():
	data = []
	for i in range (76):
		for j in range(76):
			data.append([i/75.0, j/75.0])
	tree = pickle.load(open(sys.argv[2],'rb'))
	plt.figure()
	for d in data:
		prob = [0.0,0.0,0.0,0.0]
		for t in tree:
			if d[t[0]] <= t[1]:
				if d[t[2]] <= t[3]:
					prob[t[6]-1] += t[7]
				else :
					prob[t[8]-1] += t[9]
			else:
				if d[t[4]] <= t[5]:
					prob[t[10]-1] += t[11]
				else:
					prob[t[12]-1] += t[13]
		#Take average of probabilities
		for i in range(len(prob)):
			prob[i] = prob[i] / len(tree)
		#Take majority probability
		res = prob.index(max(prob)) +1
		#bolt
		if(res == 1):
			plt.plot(d[0],d[1],'rs',ms=10)
		#nut
		if(res == 2):
			plt.plot(d[0],d[1],'bs',ms=10)
		#ring
		if(res == 3):
			plt.plot(d[0],d[1],'gs',ms=10)
		#scrap
		if(res == 4):
			plt.plot(d[0],d[1],'ks',ms=10)
	plt.title("bolt(red) nut(blue) ring(green) scrap(black)")
	plt.xlabel("Rotational Symmetry")
	plt.ylabel("Eccentricity")
	plt.show()
		
def main():
	if(len(sys.argv)<3):
		print 'Usage : >python trainDT.py test_Data.csv maxTree.p'
	else:
		#test input data
		test()
		#plot the classification region
		region()

if __name__ == '__main__':
	main()
